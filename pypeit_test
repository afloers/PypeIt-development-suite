#!/usr/bin/env python3
#
# See top-level LICENSE.rst file for Copyright information
#
# -*- coding: utf-8 -*-

"""
This script runs the PypeIt development suite of tests
"""

import sys
import os

import numpy as np
from IPython import embed

def parser(options=None):
    import argparse

    all_tests = ['kast', 'lris', 'deimos', 'nires',  # Instruments
                 'keck', 'magellan', 'vlt', 'gemini'] # Observatories
#    all_tests = ['kast', 'lris', 'isis', 'hires', 'deimos',  # Instruments
#                 'keck', 'shane', 'wht']  # Observatories

    hlpstr = ", ".join(all_tests)

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('tests', type=str, default=None,
                        help='Tests to run.  Options include: develop, all, {0:s}'.format(hlpstr))
    parser.add_argument('-outputdir', type=str, help="Output folder.  Default is ./REDUX_OUT")
    parser.add_argument('--instrument', type=str, help="Restrict to input instrument")
    parser.add_argument('-setup', type=str, help="Single out a setup to run")
    parser.add_argument('--debug', default=False, action='store_true', help='Debug')
    parser.add_argument('--prep_only', default=False, action='store_true',
                        help='Only prepare to execute run_pypeit, but do not actually run it.')

    return parser.parse_args() if options is None else parser.parse_args(options), hlpstr

def main():
#    import oslris
    import glob
    import subprocess
    import warnings
    import IPython

    pargs, hlpstr = parser()

    # TODO: Once we're satisfied than an instrument passes, add it to
    # this list!  It must pass for every directory that includes these
    # strings and all the sub-directory setups within!
    valid_instruments = ['Kast', 'DEIMOS', 'LRIS', 'NIRES', 'NIRSPEC', 'GNIRS', 'XSHOOTER', 'MAGE', 'MOSFIRE',
                         'GMOS']

    # Grab a list of all instruments
    dev_path = os.getenv('PYPEIT_DEV')
    raw_data = os.path.join(dev_path, 'RAW_DATA')

    if not os.path.isdir(raw_data):
        raise ValueError('No directory: {0}'.format(raw_data))

    #calib_data = 'PYPEIT_CALIBS'

    walk = os.walk(raw_data)
    all_instruments = next(walk)[1]

    # Setup
    if pargs.tests == 'all':
        instruments = [item for item in all_instruments for inst in valid_instruments 
                            if inst.lower() in item.lower()]
        invalid_selection = []
    elif pargs.tests == 'develop':
        invalid_selection = []
        if pargs.instrument is not None:
            instruments = [pargs.instrument]
        else:
            instruments = ['Keck_LRIS_blue', 'Gemini_GNIRS', 'Shane_Kast_blue', 'VLT_XSHOOTER',
                           'Keck_DEIMOS', 'Shane_Kast_red', 'Keck_NIRES', 'Keck_NIRSPEC', 'Keck_MOSFIRE',
                           'Keck_LRIS_red', 'Magellan_MAGE', 'Gemini_GMOS']
    else:
        instruments = [item for item in all_instruments if pargs.tests.lower() in item.lower()]
        invalid_selection = [item for item in instruments if not np.any([inst.lower()
                                    in item.lower() for inst in valid_instruments]) ]
    # Check that instruments is not blank
    if len(instruments) == 0:
        print("\x1B[" + "1;31m" + "\nERROR - " + "\x1B[" + "0m" +
              "Invalid test selected: {0:s}\n\n".format(pargs.tests) +
              "Consult the help (pypeit_test -h) or select one of the " +
              "available RAW_DATA directories: {0}".format(all_instruments))
        return 1

    if len(invalid_selection) > 0:
        print("\x1B[" + "1;33m" + "\nWARNING - " + "\x1B[" + "0m" +
              "The following tests have not been validated and may not pass: {0}\n\n".format(
              invalid_selection))

    outputdir = 'REDUX_OUT' if pargs.outputdir is None else pargs.outputdir
    if not os.path.exists(outputdir):
        os.mkdir(outputdir)
    outputdir = os.path.abspath(outputdir)

    # Loop on instruments
    npass, ntest = 0, 0

    # Do them in order Shane, LRIS, DEIMOS, since DEIMOS takes the
    # longest. To do this we sort and reverse, and then apply the kludge below
    instruments.sort(reverse=True)
    if 'Keck_DEIMOS' in instruments and len(instruments) > 2:
        instruments[-2], instruments[-1]=instruments[-1],instruments[-2]

    # Report
    print('Running tests on the following instruments:')
    for instr in instruments:
        print('    {0}'.format(instr))
    print('')

    for instr in instruments:
        # Setups
        setups = next(os.walk(os.path.join(raw_data, instr)))[1]
        # Cut me down
        if pargs.debug and ('blue' not in instr):
            continue

        # Develop cut
        if pargs.tests == 'develop':
            if instr == 'Keck_DEIMOS':
                req_setups = ['600ZD_M_6500', '1200G_M_7750', '830G_LVM_8400', '830G_M_8100_26',
                              '830G_M_8500', '830G_L_8100']
            elif instr == 'Gemini_GNIRS':
                req_setups = ['GNIRS']
            elif instr == 'Shane_Kast_blue':
                req_setups = ['452_3306_d57', '600_4310_d55']
            elif instr == 'Shane_Kast_red':
                req_setups = ['600_7500_d55_ret']
            elif instr == 'Keck_NIRES':
                req_setups = ['NIRES']
            elif instr == 'Keck_NIRSPEC':
                req_setups = ['LOW_NIRSPEC-1']
            elif instr == 'Keck_MOSFIRE':
                req_setups = ['Y_long']
            elif instr == 'Magellan_MAGE':
                req_setups = ['1x1']
            elif instr == 'Keck_LRIS_blue':
                req_setups = ['multi_600_4000_d560', 'long_400_3400_d560', 'long_600_4000_d560',
                              'multi_300_5000_d680']  #, 'multi_1200_3400_d460']
            elif instr == 'Keck_LRIS_red':
                req_setups = ['long_600_7500_d560', 'multi_1200_9000_d680_1x2',
                              'multi_600_5000_d560', 'multi_1200_9000_d680', 'multi_400_8500_d560']
            elif instr == 'VLT_XSHOOTER':
                req_setups = ['VIS_1x1', 'VIS_2x1', 'VIS_2x2', 'NIR']
            elif instr == 'Magellan_MAGE':
                req_setups = ['1x1']
            elif instr == 'Gemini_GMOS':
                req_setups = ['GS_HAM_R400_700']
            else:
                # Should not get here
                print("I don't know how you got here")
                IPython.embed(header='147 of pypeit_test')
            # Check me now
            for setup in req_setups:
                if setup not in setups:
                    print("You need to download the {} setup for the {} instrument before proceeding".format(setup, instr))
                    IPython.embed(header='156 of pypeit_test')
            setups = req_setups

        # Report
        print('The following setups have been found for {0}:'.format(instr))
        for setup in setups:
            print('    {0}'.format(setup))
        print('')

        for setup in setups:

            if pargs.setup is not None and setup != pargs.setup:
                print('Setup {0} not selected for testing.   Continuing...'.format(setup))
                print('')
                continue

            # Generate folder as need be
            idir = os.path.join(outputdir, instr)
            if not os.path.exists(idir):
                os.makedirs(idir)
            wdir = os.path.join(idir, setup)
            if not os.path.exists(wdir):
                os.makedirs(wdir)

            # rawdata
            rawdir = os.path.join(raw_data, instr, setup)

            # Report
            print('Directories:')
            print('         Raw data: {0}'.format(rawdir))
            print('    PypeIt output: {0}'.format(wdir))
            print('')

            # Run setup?
            passed = True

            # TODO: By default search for the appropriate pypeit file
            # and run pypeit_setup if it doesn't exist
            
            # TODO: Include option that forces the tests to run
            # pypeit_setup

            outfile_root = instr.lower()+'_'+setup.lower()

            if (instr.lower() in ['shane_kast_blue']) and ('600' in setup):
                # Use pypeit_setup to get the pypeit file for Shane Kast Blue
                ntest += 1
                logfile = os.path.join(wdir, outfile_root+'.test.log')
                with open(logfile, 'w') as f:
                    command_line = ['pypeit_setup', '-r', rawdir, '-s', instr.lower(), '-c all', '-o',
                                    '--output_path', wdir ]
                    print('Running command: {0}'.format(' '.join(command_line)))
                    retval = subprocess.call(command_line, stderr=f, cwd=wdir)

                wdir = os.path.join(wdir, instr.lower()+'_A')
                print('Finished running pypeit on {0} --- '.format(outfile_root),
                      file=sys.stderr, end='')

                # Run pypeit on _A.pypeit
                pyp_file = glob.glob(os.path.join(wdir, '*_A.pypeit'))
                if len(pyp_file) != 1:
                    print('Could not find expected pypeit file: {0}'.format(pyp_file))
                    print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
                    passed = False
                else:
                    pyp_file = os.path.split(pyp_file[0])[1]
                    if retval == 0:
                        print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                        npass += 1
                subprocess.call(['tail', '-2', logfile])
                print("\n", file=sys.stderr)
            else:
                # Use pre-made PypeIt file
                pyp_file = os.path.join('pypeit_files', outfile_root+'.pypeit')

                if not os.path.exists(pyp_file):
                    warnings.warn('PypeIt file {0} does not exist.  Continuing...'.format(pyp_file))
                    continue

                # Read the pypeit file
                with open(pyp_file, 'r') as infile:
                    lines = infile.readlines()

                # Replace the default path with the local one
                for kk, iline in enumerate(lines):
                    if 'data read' in iline:
                        dpth = lines[kk+1]
                        newdpth = ' path ' if 'path' in dpth else ' '
                        i0 = dpth.rfind('/')
                        if setup.strip('/') == dpth[i0:].strip('/\n'):
                            # TODO: Test is for WHT path issue...
                            newdpth += os.path.join(raw_data, instr, setup)+'\n'
                        else:
                            newdpth += os.path.join(raw_data, instr, setup+dpth[i0:])
                        lines[kk+1] = newdpth
                    elif 'flatfield' in iline and 'frame' in lines[kk+1]:
                        newcpth = os.path.join(dev_path, 'CALIBS', os.path.split(lines[kk+1])[1])
                        lines[kk+1] = '        frame = {0}'.format(newcpth)

                # Write to outputdir
                pyp_file = outfile_root+'.pypeit'
                with open(os.path.join(wdir, pyp_file), 'w') as ofile:
                    ofile.writelines(lines)

            if pargs.prep_only:
                continue
             
            # Run pypeit
            retval = -1
            if passed:
                ntest += 1
                logfile = os.path.join(wdir, outfile_root+'.test.log')
                print('Running pypeit on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(wdir))
                    command_line = [ 'run_pypeit', pyp_file, '-o' ]
                    print('Command line: {0}'.format(' '.join(command_line)))
                    retval = subprocess.call(command_line, stderr=f, cwd=wdir)
                    npass = report_test(retval, npass)
                    subprocess.call(['tail', '-2', logfile])
                    print("\n", file=sys.stderr)

                # Test master frame running
                if instr in ['keck_lris_red']:
                    ntest += 1
                    print('Running pypeit with master frames on {0} --- '.format(pyp_file),
                          file=sys.stderr, end='')
                    with open(logfile, 'w') as f:
                        print('Directory: {0}'.format(wdir))
                        command_line = [ 'run_pypeit', pyp_file, '-m', '-o' ]
                        print('Command line: {0}'.format(' '.join(command_line)))
                        retval = subprocess.call(command_line, stderr=f, cwd=wdir)
                        npass = report_test(retval, npass)
                        subprocess.call(['tail', '-2', logfile])
                        print("\n", file=sys.stderr)
            else:
                print("Couldn't run test for {0:s}".format(instr.lower()))

            # Fluxing
            if (retval == 0) and (
                    ((instr.lower() == 'shane_kast_blue') and ('600' in setup)) or
                    (instr.lower() == 'keck_nires')):
                ntest += 1
                print('Running pypeit_flux on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                logfile = os.path.join(wdir, outfile_root+'.test_flux.log')
                flux_file = os.path.join(dev_path, 'fluxing_files', instr.lower()+'.flux')
                fdir = os.path.join(wdir, 'Science')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(fdir))
                    command_line = [ 'pypeit_flux_spec', flux_file ]
                    print('Command line: {0}'.format(' '.join(command_line)))
                    fretval = subprocess.call(command_line, stderr=f, cwd=fdir)
                    npass = report_test(fretval, npass, type='FLUXING')
                    subprocess.call(['tail', '-3', logfile])
                    print("\n", file=sys.stderr)

            # 2-D coadds Echelle
            if (retval == 0) and (instr.lower() in ['gemini_gnirs']):
                ntest += 1
                print('Running pypeit_coadd_2dspec on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                logfile = os.path.join(wdir, outfile_root+'.test_2dcoadd.log')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(wdir))
                    command_line = ['pypeit_coadd_2dspec', '--obj', 'pisco']
                    print('Command line: {0}'.format(' '.join(command_line)))
                    cretval = subprocess.call(command_line, stderr=f, cwd=wdir)
                    npass = report_test(cretval, npass, type='COADD2D')
                    subprocess.call(['tail', '-3', logfile])
                    print("\n", file=sys.stderr)

            # 2-D coadds MultiSlit
            if (retval == 0) and (instr.lower() in ['keck_lris_blue']) and ('multi_600_4000_d560' in setup):
                ntest += 1
                print('Running pypeit_coadd_2dspec on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                logfile = os.path.join(wdir, outfile_root+'.test_coadd2d.log')
                coadd2d_file = os.path.join(dev_path, 'coadd2d_files', instr.lower() + '_' + setup + '.coadd2d')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(wdir))
                    command_line = ['pypeit_coadd_2dspec', '--file', coadd2d_file]
                    print('Command line: {0}'.format(' '.join(command_line)))
                    cretval = subprocess.call(command_line, stderr=f, cwd=wdir)
                    npass = report_test(cretval, npass, type='COADD2D')
                    subprocess.call(['tail', '-3', logfile])
                    print("\n", file=sys.stderr)



    if npass == ntest:
        print("\n" + "\x1B[" + "1;32m" +
              "--- PYPEIT DEVELOPMENT SUITE PASSED {0:d}/{1:d} TESTS ---".format(npass, ntest) +
              "\x1B[" + "0m" + "\r", file=sys.stderr)
    else:
        print("\n" + "\x1B[" + "1;31m" +
              "--- PYPEIT DEVELOPMENT SUITE FAILED {0:d}/{1:d} TESTS ---".format(ntest-npass,
              ntest) + "\x1B[" + "0m" + "\r", file=sys.stderr)

def report_test(retval, npass, type=None):
    if type is not None:
        fstr = type +  ' '
    else:
        fstr = ''


    if retval == 0:
        print("\x1B[" + "1;32m" + "{}PASSED".format(fstr) + "\x1B[" + "0m", file=sys.stderr)
        return npass + 1
    else:
        print("\x1B[" + "1;31m" + "{}FAILED".format(fstr) + "\x1B[" + "0m", file=sys.stderr)
        return npass

if __name__ == '__main__':
    # Check for pypeit executable
    if not any([os.access(os.path.join(path, 'run_pypeit'), os.X_OK)
                for path in os.environ["PATH"].split(os.pathsep)]):
        raise RuntimeError("You need to install run_pypeit in your PATH")
    # Giddy up
    main()


